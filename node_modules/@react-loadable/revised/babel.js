"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
// https://babeljs.io/docs/en/babel-types
// https://doc.esdoc.org/github.com/mason-lang/esast/class/src/ast.js~Property.html
// https://astexplorer.net/
var path_1 = __importDefault(require("path"));
exports["default"] = (function (_a, _b) {
    var t = _a.types;
    var _c = _b === void 0 ? {} : _b, shortenPath = _c.shortenPath, absPath = _c.absPath;
    return ({
        visitor: {
            ImportDeclaration: function (path) {
                var e_1, _a;
                var source = path.node.source.value;
                if (source !== '@react-loadable/revised')
                    return;
                var defaultSpecifier = path.get('specifiers').find(function (specifier) { return specifier.isImportDefaultSpecifier(); });
                if (!defaultSpecifier)
                    return;
                var bindingName = defaultSpecifier.node.local.name;
                var binding = path.scope.getBinding(bindingName);
                var _loop_1 = function (refPath) {
                    var e_2, _d;
                    var callExpression = refPath.parentPath;
                    if (!callExpression.isCallExpression())
                        return "continue";
                    var args = callExpression.get('arguments');
                    if (args.length !== 1)
                        throw new Error('react-loadable: must provide exactly 1 argument to loadable()');
                    var options = args[0];
                    if (!options.isObjectExpression())
                        return "continue";
                    var loader = void 0;
                    try {
                        for (var _e = (e_2 = void 0, __values(options.get('properties'))), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var property = _f.value;
                            if (property.type !== 'SpreadProperty') {
                                var key = property.get('key');
                                if (key.node.name === 'webpack')
                                    return "continue-refPath";
                                else if (key.node.name === 'loader')
                                    loader = property;
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_d = _e["return"])) _d.call(_e);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                    if (!loader)
                        throw new Error('react-loadable: at least loader or webpack properties must be statically provided to the option that is passed to loadable()');
                    var loaderValue = loader.get('value');
                    var dynamicImports = [];
                    var body = loader.isFunction()
                        ? loader.get('body')
                        : loaderValue.isArrowFunctionExpression() && loaderValue.get('body');
                    if (!body)
                        throw new Error('react-loadable: loader must be function shorthand expression or arrow function expression');
                    body.traverse({
                        Import: function (path) {
                            dynamicImports.push(path.parentPath);
                        }
                    });
                    if (!dynamicImports.length)
                        return "continue";
                    loader.insertAfter(t.objectProperty(t.identifier('webpack'), t.arrowFunctionExpression([], t.arrayExpression(dynamicImports.map(function (dynamicImport) { return t.callExpression(t.memberExpression(t.identifier('require'), t.identifier('resolveWeak')), [dynamicImport.get('arguments')[0].node]); })))));
                    var dir = path_1["default"].dirname(this_1.file.opts.filename);
                    var rootDir = this_1.file.opts.root;
                    loader.insertAfter(t.objectProperty(t.identifier('modules'), t.arrayExpression(dynamicImports.map(function (dynamicImport) {
                        var node = dynamicImport.get('arguments')[0].node;
                        if (absPath && node.type === 'StringLiteral') {
                            var value = node.value;
                            if (typeof value === 'string') {
                                var resolvedPath = absPath && value.startsWith('./') ? path_1["default"].resolve(dir, value) : value;
                                var afterShortenPath = typeof shortenPath === 'string' && resolvedPath.startsWith(rootDir)
                                    ? "".concat(shortenPath).concat(resolvedPath.slice(rootDir.length))
                                    : resolvedPath;
                                return t.stringLiteral(afterShortenPath);
                            }
                        }
                        return node;
                    }))));
                };
                var this_1 = this;
                try {
                    refPath: for (var _b = __values(binding.referencePaths), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var refPath = _c.value;
                        var state_1 = _loop_1(refPath);
                        switch (state_1) {
                            case "continue-refPath": continue refPath;
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
        }
    });
});
